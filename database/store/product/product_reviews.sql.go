// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: product_reviews.sql

package product

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createProductComment = `-- name: CreateProductComment :one
INSERT INTO
    product_comment (id, comment)
VALUES ($1, $2) RETURNING id
`

type CreateProductCommentParams struct {
	ID      uuid.UUID   `json:"id"`
	Comment pgtype.Text `json:"comment"`
}

func (q *Queries) CreateProductComment(ctx context.Context, arg CreateProductCommentParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createProductComment, arg.ID, arg.Comment)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createProductReview = `-- name: CreateProductReview :one
INSERT INTO
    product_reviews (
        id,
        user_id,
        product_id,
        seller_id,
        rating
    )
VALUES ($1, $2, $3, $4, $5) RETURNING id
`

type CreateProductReviewParams struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"user_id"`
	ProductID uuid.UUID `json:"product_id"`
	SellerID  uuid.UUID `json:"seller_id"`
	Rating    int32     `json:"rating"`
}

func (q *Queries) CreateProductReview(ctx context.Context, arg CreateProductReviewParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createProductReview,
		arg.ID,
		arg.UserID,
		arg.ProductID,
		arg.SellerID,
		arg.Rating,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteProductComment = `-- name: DeleteProductComment :exec
DELETE FROM product_comment WHERE id = $1
`

func (q *Queries) DeleteProductComment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductComment, id)
	return err
}

const deleteProductReview = `-- name: DeleteProductReview :exec
DELETE FROM product_reviews WHERE id = $1
`

func (q *Queries) DeleteProductReview(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductReview, id)
	return err
}

const getProductCommentByID = `-- name: GetProductCommentByID :one
SELECT id, comment FROM product_comment WHERE id = $1
`

func (q *Queries) GetProductCommentByID(ctx context.Context, id uuid.UUID) (ProductComment, error) {
	row := q.db.QueryRow(ctx, getProductCommentByID, id)
	var i ProductComment
	err := row.Scan(&i.ID, &i.Comment)
	return i, err
}

const getProductReviewByID = `-- name: GetProductReviewByID :one
SELECT
    id,
    user_id,
    product_id,
    seller_id,
    rating,
    created_at,
    updated_at
FROM product_reviews
WHERE
    id = $1
`

func (q *Queries) GetProductReviewByID(ctx context.Context, id uuid.UUID) (ProductReview, error) {
	row := q.db.QueryRow(ctx, getProductReviewByID, id)
	var i ProductReview
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.SellerID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProductReviews = `-- name: ListProductReviews :many
SELECT
    id,
    user_id,
    product_id,
    seller_id,
    rating,
    created_at,
    updated_at
FROM product_reviews
ORDER BY id
LIMIT $1
OFFSET
    $2
`

type ListProductReviewsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProductReviews(ctx context.Context, arg ListProductReviewsParams) ([]ProductReview, error) {
	rows, err := q.db.Query(ctx, listProductReviews, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductReview{}
	for rows.Next() {
		var i ProductReview
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductID,
			&i.SellerID,
			&i.Rating,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReviewsWithComments = `-- name: ListReviewsWithComments :many
SELECT pr.id, pr.user_id, pr.product_id, pr.seller_id, pr.rating, pr.created_at, pr.updated_at, pc.comment
FROM
    product_reviews pr
    LEFT JOIN product_comment pc ON pr.id = pc.id
WHERE
    pr.product_id = $1
ORDER BY pr.created_at DESC
LIMIT $1
OFFSET
    $2
`

type ListReviewsWithCommentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListReviewsWithCommentsRow struct {
	ID        uuid.UUID        `json:"id"`
	UserID    uuid.UUID        `json:"user_id"`
	ProductID uuid.UUID        `json:"product_id"`
	SellerID  uuid.UUID        `json:"seller_id"`
	Rating    int32            `json:"rating"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	Comment   pgtype.Text      `json:"comment"`
}

func (q *Queries) ListReviewsWithComments(ctx context.Context, arg ListReviewsWithCommentsParams) ([]ListReviewsWithCommentsRow, error) {
	rows, err := q.db.Query(ctx, listReviewsWithComments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReviewsWithCommentsRow{}
	for rows.Next() {
		var i ListReviewsWithCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductID,
			&i.SellerID,
			&i.Rating,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Comment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductComment = `-- name: UpdateProductComment :exec
UPDATE product_comment SET comment = $2 WHERE id = $1
`

type UpdateProductCommentParams struct {
	ID      uuid.UUID   `json:"id"`
	Comment pgtype.Text `json:"comment"`
}

func (q *Queries) UpdateProductComment(ctx context.Context, arg UpdateProductCommentParams) error {
	_, err := q.db.Exec(ctx, updateProductComment, arg.ID, arg.Comment)
	return err
}

const updateProductReview = `-- name: UpdateProductReview :exec
UPDATE product_reviews
SET
    user_id = $2,
    product_id = $3,
    seller_id = $4,
    rating = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $1
`

type UpdateProductReviewParams struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"user_id"`
	ProductID uuid.UUID `json:"product_id"`
	SellerID  uuid.UUID `json:"seller_id"`
	Rating    int32     `json:"rating"`
}

func (q *Queries) UpdateProductReview(ctx context.Context, arg UpdateProductReviewParams) error {
	_, err := q.db.Exec(ctx, updateProductReview,
		arg.ID,
		arg.UserID,
		arg.ProductID,
		arg.SellerID,
		arg.Rating,
	)
	return err
}
